# Spec: Generate Command

## JTBD
As a developer, I want to generate ready-to-use JavaScript/TypeScript code that implements WebMCP tool registrations, so I can copy-paste it into my project.

## Command
```bash
wmcp-annotate generate <url> [options]

Options:
  --suggest-file, -s   Use existing suggestions instead of live analysis
  --output, -o         Output file
  --format, -f         Output format: js, ts, react, vue, svelte
  --module, -m         Module format: esm, cjs
```

## Behavior

### Input
- URL to analyze (or existing suggestions file)
- Output format preference

### Process
1. Run suggest (or load suggestions file)
2. For each tool:
   - Generate registration code
   - Add execute handler stub
   - Include comments with implementation hints
3. Wrap in appropriate module format
4. Add TypeScript types if ts format

### Output Examples

#### JavaScript (ESM)
```javascript
// WebMCP Tool Registration
// Generated by wmcp-annotate
// URL: https://example.com

// Tool: searchProducts
// Search for products by keyword, category, or filters
navigator.modelContext.registerTool({
  name: "searchProducts",
  description: "Search for products by keyword, category, or filters",
  readOnly: true,
  inputSchema: {
    type: "object",
    properties: {
      query: {
        type: "string",
        description: "Search keywords"
      },
      category: {
        type: "string",
        enum: ["electronics", "clothing", "home"]
      }
    },
    required: ["query"]
  },
  async execute({ query, category }) {
    // TODO: Implement search logic
    // Suggested implementation:
    // 1. Find form: document.querySelector('#search-form')
    // 2. Fill inputs with provided values
    // 3. Submit form or make API call
    // 4. Return results

    const form = document.querySelector('#search-form');
    const queryInput = form.querySelector('input[name="query"]');
    const categorySelect = form.querySelector('select[name="category"]');
    
    queryInput.value = query;
    if (category) categorySelect.value = category;
    
    // Trigger search
    form.dispatchEvent(new Event('submit'));
    
    // Wait for results (implement based on your app)
    await new Promise(r => setTimeout(r, 1000));
    
    const results = document.querySelectorAll('.product-item');
    return {
      content: [{
        type: "text",
        text: JSON.stringify(Array.from(results).map(el => ({
          name: el.querySelector('.name')?.textContent,
          price: el.querySelector('.price')?.textContent
        })))
      }]
    };
  }
});
```

#### TypeScript
```typescript
// WebMCP Tool Registration
// Generated by wmcp-annotate

interface SearchProductsInput {
  query: string;
  category?: "electronics" | "clothing" | "home";
}

navigator.modelContext.registerTool({
  name: "searchProducts",
  description: "Search for products by keyword, category, or filters",
  readOnly: true,
  inputSchema: { /* ... */ },
  async execute(input: SearchProductsInput) {
    // Implementation
  }
});
```

#### React Hook
```typescript
// useWebMCPTools.ts
import { useEffect } from 'react';

export function useWebMCPTools() {
  useEffect(() => {
    if (!navigator.modelContext) return;
    
    const cleanup = navigator.modelContext.registerTool({
      name: "searchProducts",
      // ...
    });
    
    return () => cleanup?.();
  }, []);
}
```

## Tests
1. Generate JS → valid JavaScript that runs
2. Generate TS → valid TypeScript that compiles
3. Generate React → valid React hook
4. Multiple tools → all registered
5. Complex schemas → properly typed

## Templates
Store templates in `templates/` directory:
- `templates/js-esm.hbs`
- `templates/ts.hbs`
- `templates/react.hbs`
- `templates/vue.hbs`
