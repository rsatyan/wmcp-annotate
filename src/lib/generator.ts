import type { SuggestResult, ToolSuggestion } from '../types.js';
import Handlebars from 'handlebars';

interface GenerateOptions {
  format: 'js' | 'ts' | 'react' | 'vue';
  module: 'esm' | 'cjs';
}

const jsTemplate = Handlebars.compile(`// WebMCP Tool Registration
// Generated by wmcp-annotate
// URL: {{url}}
// Generated: {{generatedAt}}

{{#each tools}}
// Tool: {{name}}
// {{description}}
navigator.modelContext.registerTool({
  name: "{{name}}",
  description: "{{description}}",
  inputSchema: {{{schemaJson}}},
  annotations: { readOnlyHint: {{readOnly}} },
  async execute({{#if hasInputs}}{ {{inputNames}} }{{/if}}, client) {
    // TODO: Implement {{name}}
    // Source element: {{sourceElement.selector}}
    
    {{#if isForm}}
    const form = document.querySelector('{{sourceElement.selector}}');
    {{#each inputFields}}
    form.querySelector('[name="{{this}}"]').value = {{this}};
    {{/each}}
    form.submit();
    {{else}}
    const element = document.querySelector('{{sourceElement.selector}}');
    element.click();
    {{/if}}
    
    // Return results
    return {
      content: [{
        type: "text",
        text: JSON.stringify({ success: true })
      }]
    };
  }
});

{{/each}}
`);

const tsTemplate = Handlebars.compile(`// WebMCP Tool Registration
// Generated by wmcp-annotate
// URL: {{url}}

{{#each tools}}
interface {{pascalName}}Input {
{{#each inputFields}}
  {{this}}: string;
{{/each}}
}

{{/each}}
{{#each tools}}
navigator.modelContext.registerTool({
  name: "{{name}}",
  description: "{{description}}",
  inputSchema: {{{schemaJson}}},
  annotations: { readOnlyHint: {{readOnly}} },
  async execute(input: {{pascalName}}Input, client: ModelContextClient) {
    // TODO: Implement
    return { content: [{ type: "text", text: JSON.stringify({ success: true }) }] };
  }
});

{{/each}}
`);

const reactTemplate = Handlebars.compile(`// WebMCP React Hook
// Generated by wmcp-annotate

import { useEffect } from 'react';

export function useWebMCPTools() {
  useEffect(() => {
    if (!navigator.modelContext) {
      console.warn('WebMCP not available');
      return;
    }

    const cleanups: (() => void)[] = [];

{{#each tools}}
    cleanups.push(
      navigator.modelContext.registerTool({
        name: "{{name}}",
        description: "{{description}}",
        inputSchema: {{{schemaJson}}},
        annotations: { readOnlyHint: {{readOnly}} },
        async execute(input, client) {
          // TODO: Implement
          return { content: [{ type: "text", text: JSON.stringify({ success: true }) }] };
        }
      })
    );

{{/each}}
    return () => cleanups.forEach(cleanup => cleanup?.());
  }, []);
}
`);

class Generator {
  async generate(suggestions: SuggestResult, options: GenerateOptions): Promise<string> {
    const data = {
      url: suggestions.url,
      generatedAt: new Date().toISOString(),
      tools: suggestions.tools.map(tool => this.prepareToolData(tool)),
    };

    switch (options.format) {
      case 'ts':
        return tsTemplate(data);
      case 'react':
        return reactTemplate(data);
      case 'vue':
        // Vue is similar to React for this use case
        return reactTemplate(data).replace('useWebMCPTools', 'useWebMCPTools');
      default:
        return jsTemplate(data);
    }
  }

  private prepareToolData(tool: ToolSuggestion) {
    const inputFields = tool.inputSchema.properties 
      ? Object.keys(tool.inputSchema.properties)
      : [];
    
    return {
      ...tool,
      schemaJson: JSON.stringify(tool.inputSchema, null, 2),
      hasInputs: inputFields.length > 0,
      inputNames: inputFields.join(', '),
      inputFields,
      isForm: tool.sourceElement.type === 'form',
      pascalName: tool.name.charAt(0).toUpperCase() + tool.name.slice(1),
    };
  }
}

export const generator = new Generator();
